java_qbnk = [{"question": "Which of the following is not OOP concept in Java?","options": ["Inheritance","Encapsulation","Polymorphism","Compilation"],"answer": "Compilation","explain": "There are 4 OOPS concepts in Java. Inheritance, Encapsulation, Polymorphism and Abstraction.","difficulty": 2},{"question": "Which of the following is a type of polymorphism in Java?","options": ["Compile time polymorphism","Execution time polymorphism","Multiple polymorphism","Multilevel polymorphism"],"answer": "Compile time polymorphism","explain": "There are two type of polymorphism in Java. Compile time polymorphism (overloading) and runtime polymorphism (overriding).","difficulty": 4},{"question": "When does method overloading is determined?","options": ["At run time","At compile time","At coding time","At execution time"],"answer": "At compile time","explain": "Overloading is determined at compile time. Hence, it is also known as compile time polymorphism.","difficulty": 3},{"question": "When Overloading does not occur?","options": ["More than one method with same name but different method signature and different number or type of parameters","More than one method with same name, same signature but different number of signature","More than one method with same name, same signature, same number of parameters but different type","More than one method with same name, same number of parameters and type but different signature"],"answer": "More than one method with same name, same number of parameters and type but different signature","explain": "Overloading occurs when more than one method with same name but different constructor and also when same signature but different number of parameters and/or parameter type.","difficulty": 3},{"question": "Which concept of Java is a way of converting real world objects in terms of class?","options": ["Polymorphism","Encapsulation","Abstraction","Inheritance"],"answer": "Abstraction","explain": "Abstraction is concept of defining real world objects in terms of classes or interfaces.","difficulty": 4},{"question": "Which concept of Java is achieved by combining methods and attribute into a class?","options": ["Encapsulation","Inheritance","Polymorphism","Abstraction"],"answer": "Encapsulation","explain": "Encapsulation is implemented by combining methods and attribute into a class. The class acts like a container of encapsulating properties.","difficulty": 2},{"question": "What is it called if an object has its own lifecycle and there is no owner?","options": ["Aggregation","Composition","Encapsulation","Association"],"answer": "Association","explain": "It is a relationship where all objects have their own lifecycle and there is no owner. This occurs where many to many relationship is available, instead of one to one or one to many.","difficulty": 1},{"question": "What is it called where child object gets killed if parent object is killed?","options": ["Aggregation","Composition","Encapsulation","Association"],"answer": "Composition","explain": "Composition occurs when child object gets killed if parent object gets killed. Aggregation is also known as strong Aggregation.","difficulty": 3},{"question": "What is it called where object has its own lifecycle and child object cannot belong to another parent object?","options": ["Aggregation","Composition","Encapsulation","Association"],"answer": "Aggregation","explain": "Aggregation occurs when objects have their own life cycle and child object can associate with only one parent object.","difficulty": 4},{"question": "Method overriding is combination of inheritance and polymorphism?","options": ["True","false"],"answer": "True","explain": "In order for method overriding, method with same signature in both superclass and subclass is required with same signature. That satisfies both concepts inheritance and polymorphism.","difficulty": 2},{"question": "Which component is used to compile, debug and execute java program?","options": ["JVM","JDK","JIT","JRE"],"answer": "JDK","explain": "JDK is core component of Java Environment and provides all the tools, executables and binaries required to compile, debug and execute a Java Program.","difficulty": 3},{"question": "Which component is responsible for converting bytecode into machine specific code?","options": ["JVM","JDK","JIT","JRE"],"answer": "JVM","explain": "JVM is responsible to converting bytecode to the machine specific code. JVM is also platform dependent and provides core java functions like garbage collection,memory management, security etc.","difficulty": 1},{"question": "Which component is responsible to run java program?","options": ["JVM","JDK","JIT","JRE"],"answer": "JRE","explain": "JRE is the implementation of JVM, it provides platform to execute java programs.","difficulty": 1},{"question": "Which component is responsible to optimize bytecode to machine code?","options": ["JVM","JDK","JIT","JRE"],"answer": "JIT","explain": "JIT optimizes bytecode to machine specific language code by compiling similar bytecodes at same time.This reduces overall time taken for compilation of bytecode to machine specific language.","difficulty": 4},{"question": "Which statement is true about java?","options": ["Platform independent programming language","Platform dependent programming language","Code dependent programming language","Sequence dependent programming language"],"answer": "Platform independent programming language","explain": "Java is called Ã¢â‚¬ËœPlatform Independent LanguageÃ¢â‚¬â„¢ as it primarily works on the principle of Ã¢â‚¬Ëœcompile once, run everywhereÃ¢â‚¬â„¢.","difficulty": 4},{"question": "Which of the below is invalid identifier with main method?","options": ["public","static","private","final"],"answer": "private","explain": "main method cannot be private as it is invoked by external method. Other identifier are valid with main method.","difficulty": 3},{"question": "What is the extension of java code files?","options": [".class",".java",".txt",".js"],"answer": ".java","explain": "Java files have .java extension.","difficulty": 4},{"question": "What is the extension of compiled java classes?","options": [".class",".java",".txt",".js"],"answer": ".class","explain": "The compiled java files have .class extension.","difficulty": 1},{"question": "How can we identify whether a compilation unit is class or interface from a .class file?","options": ["Java source file header","Extension of compilation unit","We cannot differentiate between class and interface","The class or interface name should be postfixed with unit type"],"answer": "Java source file header","explain": "The Java source file contains a header that declares the type of class or interface, its visibility with respect to other classes, its name and any superclass it may extend, or interface it implements.","difficulty": 2},{"question": "What is use of interpreter?","options": ["They convert bytecode to machine language code","They read high level code and execute them","They are intermediated between JIT and JVM","It is a synonym for JIT","and execute the program. Interpreters are normally not passing through byte-code and jit compilation."],"answer": "They read high level code and execute them","explain": "Interpreters read high level language (interprets it) and execute the program. Interpreters are normally not passing through byte-code and jit compilation.","difficulty": 4},{"question": "What is true about private constructor?","options": ["Private constructor ensures only one instance of a class exist at any point of time","Private constructor ensures multiple instances of a class exist at any point of time","Private constructor eases the instantiation of a class","Private constructor allows creating objects in other classes"],"answer": "Private constructor ensures only one instance of a class exist at any point of time","explain": "Object of private constructor can only be created within class. Private constructor is used in singleton pattern.","difficulty": 2},{"question": "What would be the behaviour if this() and super() used in a method?","options": ["Runtime error","Throws exception","compile time error","Runs successfully"],"answer": "compile time error","explain": "this() and super() cannot be used in a method. This throws compile time error.","difficulty": 3},{"question": "What is false about constructor?","options": ["Constructors cannot be synchronized in Java","Java does not provide default copy constructor","Constructor can be overloaded","this and super can be used in a constructor"],"answer": "Constructor can be overloaded","explain": "Default, parameterised constructors can be defined.","difficulty": 1},{"question": "What is true about Class.getInstance()?","options": ["Class.getInstance calls the constructor","Class.getInstance is same as new operator","Class.getInstance needs to have matching constructor","Class.getInstance creates object if class does not have any constructor"],"answer": "Class.getInstance creates object if class does not have any constructor","explain": "Class class provides list of methods for use like getInstance().","difficulty": 4},{"question": "What is true about constructor?","options": ["It can contain return type","It can take any number of parameters","It can have any non access modifiers","Constructor cannot throw exception"],"answer": "It can take any number of parameters","explain": "Constructor returns a new object with variables defined as in the class. Instance variables are newly created and only one copy of static variables are created.","difficulty": 3},{"question": "Abstract class cannot have a constructor.","options": ["True","False"],"answer": "False","explain": "No instance can be created of abstract class. Only pointer can hold instance of object.","difficulty": 1},{"question": "What is true about protected constructor?","options": ["Protected constructor can be called directly","Protected constructor can only be called using super()","Protected constructor can be used outside package","protected constructor can be instantiated even if child is in a different package"],"answer": "Protected constructor can only be called using super()","explain": "Protected access modifier means that constructor can be accessed by child classes of the parent class and classes in the same package.","difficulty": 3},{"question": "What is not the use of this keyword in Java?","options": ["Passing itself to another method","Calling another constructor in constructor chaining","Referring to the instance variable when local variable has the same name","Passing itself to method of the same class"],"answer": "Passing itself to method of the same class","explain": "this is an important keyword in java. It helps to distinguish between local variable and variables passed in the method as parameters.","difficulty": 2},{"question": "What would be the behaviour if one parameterized constructor is explicitly defined?","options": ["Compilation error","Compilation succeeds","Runtime error","Compilation succeeds but at the time of creating object using default constructor, it throws compilation error"],"answer": "Compilation succeeds but at the time of creating object using default constructor, it throws compilation error","explain": "The class compiles successfully. But the object creation of that class gives compilation error.","difficulty": 4},{"question": "What would be behaviour if constructor has a return type?","options": ["Compilation error","Runtime error","Compilation and runs successfully","Only String return type is allowed"],"answer": "Compilation error","explain": "The constructor cannot have a return type. It should create and return new object. Hence it would give compilation error.","difficulty": 3}]

function rndUnfrm(n) {
    return ~~(Math.random() * n);
}

function shuffle(array) {
    var currentIndex = array.length, temporaryValue, randomIndex;

    while (currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }

    return array;
}

class Test {

    static init(l, questions)
    {
        var obj = {};
        obj.picked = [];
        obj.level = Test.stratify(questions);
        obj.length = l;
        obj.progress = 0;
        return obj;
    }

    static stratify(questions) {
        var level = [];
        for (var x of questions) {
            if (level[x['difficulty']] == undefined)
                level[x['difficulty']] = [];
                level[x['difficulty']].push(x);
        }
        return level;
    }

    static pickQuestion(obj, diff) {
        if (!obj.level[diff]) return false;

        var pos = rndUnfrm(obj.level[diff].length);
        obj.picked.push(obj.level[diff][pos]);
        obj.level[diff].splice(pos, 1);

        return obj.picked[obj.picked.length - 1];
    }

    static answerLastQuestion(obj, answer)
    {
        var currentQuestion = obj.picked[obj.picked.length - 1];
        currentQuestion.userAnswer = answer;
        currentQuestion.isCorrect = currentQuestion.userAnswer == currentQuestion.answer;
    }

    static markTest(obj)
    {
        obj.score = obj.picked.filter(x => x.isCorrect).length;
    }

    static upperDiff(obj, diff)
    {
        while(!obj.level[++diff])
            if(diff > obj.level.length)
                return false;
        return diff;
     }

     static lowerDiff(obj, diff)
     {
         while(!obj.level[--diff])
             if(diff < 0)
                 return false;
         return diff;
      }
}

module.exports = {Test, java_qbnk};
